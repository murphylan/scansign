---
description: React 组件开发规范 - 适用于页面和组件文件
globs:
  - app/**/*.tsx
  - components/**/*.tsx
---

# React 组件规范

> **重要**: 页面组件必须通过 Hooks 调用 Server Actions，禁止使用 fetch('/api/...')

## 页面组件模板

```tsx
"use client";

// 1. React
import * as React from "react";
import { useCallback, useEffect, useState, useTransition } from "react";

// 2. Next.js
import { useRouter } from "next/navigation";

// 3. Third-party
import { useTopLoader } from "nextjs-toploader";
import { toast } from "sonner";

// 4. UI Components
import { Button } from "@/components/ui/button";

// 5. Business Components
import PageContainer from "@/components/page-container";

// 6. Hooks（调用 Server Actions）
import { useEntities } from "@/hooks/use-entities";

// 7. Types
import type { EntityFormData } from "@/types/entity-types";

export default function CreateEntityPage() {
  // 1. Hooks
  const router = useRouter();
  const [isPending, startTransition] = useTransition();
  const { start, done } = useTopLoader();
  const { createEntityMutation } = useEntities();

  // 2. State
  const [selectedId, setSelectedId] = useState("");

  // 3. Callbacks（通过 Hook 调用 Server Action）
  const handleCreate = useCallback(
    async (values: EntityFormData) => {
      start();
      try {
        const res = await createEntityMutation.mutateAsync(values);
        if (res.success) {
          toast.success("创建成功");
          router.push("/entities");
        } else {
          toast.error(res.error || "创建失败");
        }
      } finally {
        done();
      }
    },
    [createEntityMutation, router] // ⚠️ 不添加 start/done
  );

  // 4. Effects
  useEffect(() => {
    // 初始化逻辑
  }, []);

  // 5. Render
  return (
    <PageContainer>
      <EntityForm
        onSubmit={handleCreate}
        submitting={createEntityMutation.isPending}
      />
    </PageContainer>
  );
}
```

## 加载状态规范

### useTopLoader 使用

```tsx
const { start, done } = useTopLoader();

const handleAction = useCallback(async () => {
  start();
  try {
    // 调用 mutation（不是 fetch）
    const res = await mutation.mutateAsync(data);
  } finally {
    done();
  }
}, [mutation]); // ⚠️ 不包含 start/done，防止死循环
```

## 删除功能规范

必须使用 `DeleteConfirm` 组件：

```tsx
import { DeleteConfirm } from "@/components/shared/confirm-dialog";

function EntityRow({ entity }: { entity: Entity }) {
  const { deleteEntityMutation } = useEntities();
  const { start, done } = useTopLoader();

  const handleDelete = useCallback(async () => {
    start();
    try {
      const res = await deleteEntityMutation.mutateAsync(entity.id);
      if (res.success) {
        toast.success("已删除");
      } else {
        toast.error(res.error || "删除失败");
      }
    } finally {
      done();
    }
  }, [entity.id, deleteEntityMutation]);

  return (
    <DeleteConfirm
      entityName={entity.title}
      isLoading={deleteEntityMutation.isPending}
      onConfirm={handleDelete}
    />
  );
}
```

## 检查清单

- [ ] 使用 Hooks 调用 Server Actions（不是 fetch）
- [ ] 使用 `useTopLoader` 显示加载状态
- [ ] 使用 `toast` 提示操作结果
- [ ] 使用 `mutation.isPending` 而非 `isLoading`
- [ ] 使用 try-finally（不用 try-catch 捕获 mutation 错误）
- [ ] `start`/`done` 不在 useCallback 依赖中
- [ ] 删除使用 `DeleteConfirm` 组件
- [ ] 表格列定义使用 `useMemo`

## 禁止事项

- ❌ 使用 fetch('/api/...') 获取/提交数据
- ❌ 使用 `window.confirm`
- ❌ 使用 try-catch 捕获 mutation 错误
- ❌ 将 `start`/`done` 添加到 useCallback 依赖
- ❌ 使用 `isLoading` 而非 `isPending`
- ❌ 表格列定义不使用 `useMemo`
